grid1 <- c(0:1000)/1000
prior <- dbeta(grid1, alpha,lambda)
alpha_post <- alpha + y; lambda_post <- lambda + n - y
posterior <- dbeta(grid1, alpha_post, lambda_post)
txt <- c(expression(paste("Prior: ", f(theta))),
expression(paste("Posterior: f(", theta, "|y,n)")))
leg.txt <- c(bquote(alpha == .(alpha)),
bquote(lambda == .(lambda)),
bquote(heads == .(y)),
bquote(tosses == .(n)))
plot(grid1, prior, type="h", pch = ".", col = fill[1],
bty = "l", yaxt = "n", cex.lab = 1.5,
xlab = expression(theta), ylab = "")
points(grid1, posterior, pch=".", type="h", col = new.fill2)
mtext(side = 3, text = txt, col = fill, adj = c(0,1))
legend("left", legend = as.expression(leg.txt), title = "Parameters",
title.adj = 0.05, bty = "n", inset = 0.05, cex = 0.75, y.intersp = 0.75)
MAP <- grid1[which.max(posterior)]
segments(x0 = MAP, y0 = 0, y1 = max(posterior), lty = 2)
points(MAP, max(posterior), pch = 20)
text(x = MAP, y = max(posterior)*0.75, labels = paste("MAP =", round(MAP, 3)), pos = 2, srt = 90)
}
betaprior_posterior(.5, .5, sum(coin.tosses == "Heads"), n.tosses)
betaprior_posterior=function(alpha, lambda, y, n, fill = c("purple4", "turquoise4")){
#alpha and lambda are prior parameters, y is the number of successes in n trials
require(scales)
if (y>n)  stop("Stop: y should be less than n")
new.fill2 <- alpha(fill[2], alpha = 0.75) # make transparent color
grid1 <- c(0:1000)/1000
prior <- dbeta(grid1, alpha,lambda)
alpha_post <- alpha + y; lambda_post <- lambda + n - y
posterior <- dbeta(grid1, alpha_post, lambda_post)
txt <- c(expression(paste("Prior: ", f(theta))),
expression(paste("Posterior: f(", theta, "|y,n)")))
leg.txt <- c(bquote(alpha == .(alpha)),
bquote(lambda == .(lambda)),
bquote(heads == .(y)),
bquote(tosses == .(n)))
sub.txt <- paste("alpha =",alpha," lambda =", lambda," heads =",y," tosses = ",n)
plot(grid1, prior, type="h", pch = ".", col = fill[1],
bty = "l", yaxt = "n", cex.lab = 1.5,
xlab = expression(theta), ylab = "", sub = sub.txt)
points(grid1, posterior, pch=".", type="h", col = new.fill2)
mtext(side = 3, text = txt, col = fill, adj = c(0,1))
legend("left", legend = as.expression(leg.txt), title = "Parameters",
title.adj = 0.05, bty = "n", inset = 0.05, cex = 0.75, y.intersp = 0.75)
MAP <- grid1[which.max(posterior)]
segments(x0 = MAP, y0 = 0, y1 = max(posterior), lty = 2)
points(MAP, max(posterior), pch = 20)
text(x = MAP, y = max(posterior)*0.75, labels = paste("MAP =", round(MAP, 3)), pos = 2, srt = 90)
}
betaprior_posterior(.5, .5, sum(coin.tosses == "Heads"), n.tosses)
betaprior_posterior=function(alpha, lambda, y, n, fill = c("purple4", "turquoise4")){
#alpha and lambda are prior parameters, y is the number of successes in n trials
require(scales)
if (y>n)  stop("Stop: y should be less than n")
new.fill2 <- alpha(fill[2], alpha = 0.75) # make transparent color
grid1 <- c(0:1000)/1000
prior <- dbeta(grid1, alpha,lambda)
alpha_post <- alpha + y; lambda_post <- lambda + n - y
posterior <- dbeta(grid1, alpha_post, lambda_post)
txt <- c(expression(paste("Prior: ", f(theta))),
expression(paste("Posterior: f(", theta, "|y,n)")))
leg.txt <- c(bquote(alpha == .(alpha)),
bquote(lambda == .(lambda)),
bquote(heads == .(y)),
bquote(tosses == .(n)))
sub.txt <- paste("alpha =",alpha," lambda =", lambda," heads =",y," tosses = ",n)
plot(grid1, prior, type="h", pch = ".", col = fill[1],
bty = "l", yaxt = "n", ylab = "", sub = sub.txt.,
xlab = expression(theta))
points(grid1, posterior, pch=".", type="h", col = new.fill2)
mtext(side = 3, text = txt, col = fill, adj = c(0,1))
legend("left", legend = as.expression(leg.txt), title = "Parameters",
title.adj = 0.05, bty = "n", inset = 0.05, cex = 0.75, y.intersp = 0.75)
MAP <- grid1[which.max(posterior)]
segments(x0 = MAP, y0 = 0, y1 = max(posterior), lty = 2)
points(MAP, max(posterior), pch = 20)
text(x = MAP, y = max(posterior)*0.75, labels = paste("MAP =", round(MAP, 3)), pos = 2, srt = 90)
}
betaprior_posterior(.5, .5, sum(coin.tosses == "Heads"), n.tosses)
betaprior_posterior=function(alpha, lambda, y, n, fill = c("purple4", "turquoise4")){
#alpha and lambda are prior parameters, y is the number of successes in n trials
require(scales)
if (y>n)  stop("Stop: y should be less than n")
new.fill2 <- alpha(fill[2], alpha = 0.75) # make transparent color
grid1 <- c(0:1000)/1000
prior <- dbeta(grid1, alpha,lambda)
alpha_post <- alpha + y; lambda_post <- lambda + n - y
posterior <- dbeta(grid1, alpha_post, lambda_post)
txt <- c(expression(paste("Prior: ", f(theta))),
expression(paste("Posterior: f(", theta, "|y,n)")))
leg.txt <- c(bquote(alpha == .(alpha)),
bquote(lambda == .(lambda)),
bquote(heads == .(y)),
bquote(tosses == .(n)))
sub.txt <- paste("alpha =",alpha," lambda =", lambda," heads =",y," tosses = ",n)
plot(grid1, prior, type="h", pch = ".", col = fill[1],
bty = "l", yaxt = "n", ylab = "", sub = sub.txt,
xlab = expression(theta))
points(grid1, posterior, pch=".", type="h", col = new.fill2)
mtext(side = 3, text = txt, col = fill, adj = c(0,1))
legend("left", legend = as.expression(leg.txt), title = "Parameters",
title.adj = 0.05, bty = "n", inset = 0.05, cex = 0.75, y.intersp = 0.75)
MAP <- grid1[which.max(posterior)]
segments(x0 = MAP, y0 = 0, y1 = max(posterior), lty = 2)
points(MAP, max(posterior), pch = 20)
text(x = MAP, y = max(posterior)*0.75, labels = paste("MAP =", round(MAP, 3)), pos = 2, srt = 90)
}
betaprior_posterior(.5, .5, sum(coin.tosses == "Heads"), n.tosses)
betaprior_posterior=function(alpha, lambda, y, n, fill = c("purple4", "turquoise4")){
#alpha and lambda are prior parameters, y is the number of successes in n trials
require(scales)
if (y>n)  stop("Stop: y should be less than n")
new.fill2 <- alpha(fill[2], alpha = 0.75) # make transparent color
grid1 <- c(0:1000)/1000
prior <- dbeta(grid1, alpha,lambda)
alpha_post <- alpha + y; lambda_post <- lambda + n - y
posterior <- dbeta(grid1, alpha_post, lambda_post)
txt <- c(expression(paste("Prior: ", f(theta))),
expression(paste("Posterior: f(", theta, "|y,n)")))
sub.txt <- paste("alpha =",alpha," lambda =", lambda," heads =",y," tosses = ",n)
plot(grid1, prior, type="h", pch = ".", col = fill[1],
bty = "l", yaxt = "n", ylab = "", sub = sub.txt,
cex.sub = 0.75, xlab = expression(theta))
points(grid1, posterior, pch=".", type="h", col = new.fill2)
mtext(side = 3, text = txt, col = fill, adj = c(0,1))
legend("left", legend = as.expression(leg.txt), title = "Parameters",
title.adj = 0.05, bty = "n", inset = 0.05, cex = 0.75, y.intersp = 0.75)
MAP <- grid1[which.max(posterior)]
segments(x0 = MAP, y0 = 0, y1 = max(posterior), lty = 2)
points(MAP, max(posterior), pch = 20)
text(x = MAP, y = max(posterior)*0.75, labels = paste("MAP =", round(MAP, 3)), pos = 2, srt = 90)
}
betaprior_posterior(.5, .5, sum(coin.tosses == "Heads"), n.tosses)
betaprior_posterior=function(alpha, lambda, y, n, fill = c("purple4", "turquoise4")){
#alpha and lambda are prior parameters, y is the number of successes in n trials
require(scales)
if (y>n)  stop("Stop: y should be less than n")
new.fill2 <- alpha(fill[2], alpha = 0.75) # make transparent color
grid1 <- c(0:1000)/1000
prior <- dbeta(grid1, alpha,lambda)
alpha_post <- alpha + y; lambda_post <- lambda + n - y
posterior <- dbeta(grid1, alpha_post, lambda_post)
MAP <- grid1[which.max(posterior)]
txt <- c(expression(paste("Prior: ", f(theta))),
expression(paste("Posterior: f(", theta, "|y,n)")))
sub.txt <- paste("alpha =",alpha," lambda =", lambda," heads =",y," tosses = ",n)
plot(grid1, prior, type="h", pch = ".", col = fill[1],
bty = "l", yaxt = "n", ylab = "", sub = sub.txt,
cex.sub = 0.75, xlab = expression(theta))
points(grid1, posterior, pch=".", type="h", col = new.fill2)
segments(x0 = MAP, y0 = 0, y1 = max(posterior), lty = 2)
points(MAP, max(posterior), pch = 20)
mtext(side = 3, text = txt, col = fill, adj = c(0,1))
text(x = MAP, y = max(posterior)*0.75, labels = paste("MAP =", round(MAP, 3)), pos = 2, srt = 90)
}
betaprior_posterior(.5, .5, sum(coin.tosses == "Heads"), n.tosses)
betaprior_posterior(1, 2, sum(coin.tosses == "Heads"), n.tosses)
betaprior_posterior(.25, .25, sum(coin.tosses == "Heads"), n.tosses)
betaprior_posterior(.25, 1, sum(coin.tosses == "Heads"), n.tosses)
betaprior_posterior(1, .25, sum(coin.tosses == "Heads"), n.tosses)
betaprior_posterior(1, 1, sum(coin.tosses == "Heads"), n.tosses)
betaprior_posterior=function(alpha, lambda, y, n, fill = c("purple4", "turquoise4")){
#alpha and lambda are prior parameters, y is the number of successes in n trials
require(scales)
if (y>n)  stop("Stop: y should be less than n")
new.fill2 <- alpha(fill[2], alpha = 0.75) # make transparent color
grid1 <- c(0:1000)/1000
prior <- dbeta(grid1, alpha,lambda)
alpha_post <- alpha + y; lambda_post <- lambda + n - y
posterior <- dbeta(grid1, alpha_post, lambda_post)
MAP <- grid1[which.max(posterior)]
txt <- c(expression(paste("Prior: ", f(theta))),
expression(paste("Posterior: f(", theta, "|y,n)")))
sub.txt <- paste("alpha =",alpha," lambda =", lambda," heads =",y," tosses = ",n)
plot(grid1, prior, ylim = c(0, max(posterior) + 1), type="h", pch = ".", col = fill[1],
bty = "l", yaxt = "n", ylab = "", sub = sub.txt,
cex.sub = 0.75, xlab = expression(theta))
points(grid1, posterior, pch=".", type="h", col = new.fill2)
segments(x0 = MAP, y0 = 0, y1 = max(posterior), lty = 2)
points(MAP, max(posterior), pch = 20)
mtext(side = 3, text = txt, col = fill, adj = c(0,1))
text(x = MAP, y = max(posterior)*0.75, labels = paste("MAP =", round(MAP, 3)), pos = 2, srt = 90)
}
betaprior_posterior(1, 1, sum(coin.tosses == "Heads"), n.tosses)
betaprior_posterior=function(alpha, lambda, y, n, fill = c("purple4", "turquoise4")){
#alpha and lambda are prior parameters, y is the number of successes in n trials
require(scales)
if (y>n)  stop("Stop: y should be less than n")
new.fill2 <- alpha(fill[2], alpha = 0.75) # make transparent color
grid1 <- c(0:1000)/1000
prior <- dbeta(grid1, alpha,lambda)
alpha_post <- alpha + y; lambda_post <- lambda + n - y
posterior <- dbeta(grid1, alpha_post, lambda_post)
MAP <- grid1[which.max(posterior)]
txt <- c(expression(paste("Prior: ", f(theta))),
expression(paste("Posterior: f(", theta, "|y,n)")))
sub.txt <- paste("alpha =",alpha," lambda =", lambda," heads =",y," tosses = ",n)
plot(grid1, prior, ylim = c(0, max(posterior) + 1), type="h", pch = ".", col = fill[1],
bty = "l", yaxt = "n", ylab = "", sub = sub.txt,
cex.sub = 0.75, xlab = expression(theta))
points(grid1, posterior, pch=".", type="h", col = new.fill2)
segments(x0 = MAP, y0 = 0, y1 = max(posterior), lty = 2)
points(MAP, max(posterior), pch = 20)
mtext(side = 3, text = txt, col = fill, adj = c(0,1))
text(x = MAP, y = max(posterior)*0.75, labels = paste("MAP =", round(MAP, 3)), pos = 2, srt = 90)
}
betaprior_posterior(.5, .5, sum(coin.tosses == "Heads"), n.tosses)
betaprior_posterior=function(alpha, lambda, y, n, fill = c("purple4", "turquoise4")){
#alpha and lambda are prior parameters, y is the number of successes in n trials
require(scales)
if (y>n)  stop("Stop: y should be less than n")
new.fill2 <- alpha(fill[2], alpha = 0.75) # make transparent color
grid1 <- c(0:1000)/1000
prior <- dbeta(grid1, alpha,lambda)
alpha_post <- alpha + y; lambda_post <- lambda + n - y
posterior <- dbeta(grid1, alpha_post, lambda_post)
MAP <- grid1[which.max(posterior)]
txt <- c(expression(paste("Prior: ", f(theta))),
expression(paste("Posterior: f(", theta, "|y,n)")))
sub.txt <- paste("alpha =",alpha," lambda =", lambda," heads =",y," tosses = ",n)
plot(grid1, prior, ylim = c(0, max(posterior) + 1), type="h", pch = ".", col = fill[1],
bty = "l", yaxt = "n", ylab = "", sub = sub.txt,
cex.sub = 0.75, xlab = expression(theta))
points(grid1, posterior, pch=".", type="h", col = new.fill2)
segments(x0 = MAP, y0 = 0, y1 = max(posterior), lty = 2)
points(MAP, max(posterior), pch = 20)
mtext(side = 3, text = txt, col = fill, adj = c(0,1))
text(x = MAP, y = max(posterior)*0.75, labels = paste("MAP =", round(MAP, 3)), pos = 2, srt = 90)
}
betaprior_posterior(2, 2, sum(coin.tosses == "Heads"), n.tosses)
betaprior_posterior(100, 100, sum(coin.tosses == "Heads"), n.tosses)
betaprior_posterior=function(alpha, lambda, y, n, fill = c("purple4", "turquoise4")){
#alpha and lambda are prior parameters, y is the number of successes in n trials
require(scales)
if (y>n)  stop("Stop: y should be less than n")
new.fill2 <- alpha(fill[2], alpha = 0.75) # make transparent color
grid1 <- c(0:1000)/1000
prior <- dbeta(grid1, alpha,lambda)
alpha_post <- alpha + y; lambda_post <- lambda + n - y
posterior <- dbeta(grid1, alpha_post, lambda_post)
MAP <- grid1[which.max(posterior)]
txt <- c(expression(paste("Prior: ", f(theta))),
expression(paste("Posterior: f(", theta, "|y,n)")))
sub.txt <- paste("alpha =",alpha," lambda =", lambda," heads =",y," tosses = ",n)
plot(grid1, prior, ylim = c(0, max(posterior) + 1), type="h", pch = ".", col = fill[1],
bty = "l", yaxt = "n", ylab = "", sub = sub.txt,
cex.sub = 0.75, xlab = expression(theta))
points(grid1, posterior, pch=".", type="h", col = new.fill2)
segments(x0 = MAP, y0 = 0, y1 = max(posterior), lty = 2)
points(MAP, max(posterior), pch = 20)
mtext(side = 3, text = txt, col = fill, adj = c(0,1))
text(x = MAP, y = max(posterior), labels = paste("MAP =", round(MAP, 3)), pos = 2)
}
betaprior_posterior(100, 100, sum(coin.tosses == "Heads"), n.tosses)
betaprior_posterior=function(alpha, lambda, y, n, fill = c("purple4", "turquoise4")){
#alpha and lambda are prior parameters, y is the number of successes in n trials
require(scales)
if (y>n)  stop("Stop: y should be less than n")
new.fill2 <- alpha(fill[2], alpha = 0.75) # make transparent color
grid1 <- c(0:1000)/1000
prior <- dbeta(grid1, alpha,lambda)
alpha_post <- alpha + y; lambda_post <- lambda + n - y
posterior <- dbeta(grid1, alpha_post, lambda_post)
MAP <- grid1[which.max(posterior)]
txt <- c(expression(paste("Prior: ", f(theta))),
expression(paste("Posterior: f(", theta, "|y,n)")))
sub.txt <- paste("alpha =",alpha," lambda =", lambda," heads =",y," tosses = ",n)
plot(grid1, prior, ylim = c(0, max(posterior) + 1), type="h", pch = ".", col = fill[1],
bty = "l", yaxt = "n", ylab = "", sub = sub.txt,
cex.sub = 0.75, xlab = expression(theta))
points(grid1, posterior, pch=".", type="h", col = new.fill2)
segments(x0 = MAP, y0 = 0, y1 = max(posterior), lty = 2)
points(MAP, max(posterior), pch = 20)
mtext(side = 3, text = txt, col = fill, adj = c(0,1))
text(x = MAP, y = max(posterior), labels = paste("MAP =", round(MAP, 3)), pos = 2)
}
betaprior_posterior(50, 50, sum(coin.tosses == "Heads"), n.tosses)
pars <- list(alpha = c(1, 5, 10), lambda = c(1, 5, 30))
pars[2,2]
pars$alpha[2]
betaprior_posterior(c(1,1), sum(coin.tosses == "Heads"), n.tosses)
pars <- cbind(alpha = c(1,5,10), lambda = c(1, 5, 30))
Y <- c(50, 25, 75)
par(mfrow = c(3,3))
for(i in 1:3){
for(j in 1:3){
betaprior_posterior(pars[i,1], pars[i,2], y = Y[j], n.tosses = 100)
}
}
pars <- cbind(alpha = c(1,5,10), lambda = c(1, 5, 30))
Y <- c(50, 25, 75)
par(mfrow = c(3,3))
for(i in 1:3){
for(j in 1:3){
betaprior_posterior(pars[i,1], pars[i,2], y = Y[j], n = 100)
}
}
betaprior_posterior(1,1, sum(coin.tosses == "Heads"), n.tosses)
par(mfrow = c(1,1))
betaprior_posterior(1,1, sum(coin.tosses == "Heads"), n.tosses)
betaPriorPosterior(1,1, sum(coin.tosses == "Heads"), n.tosses)
betaPriorPosterior <- function(alpha, lambda, y, n, fill = c("purple4", "turquoise4")){
#alpha and lambda are prior parameters, y is the number of successes in n trials
require(scales)
if (y>n)  stop("Stop: y should be less than n")
new.fill2 <- alpha(fill[2], alpha = 0.75) # make transparent color
grid1 <- c(0:1000)/1000
prior <- dbeta(grid1, alpha,lambda)
alpha_post <- alpha + y; lambda_post <- lambda + n - y
posterior <- dbeta(grid1, alpha_post, lambda_post)
MAP <- grid1[which.max(posterior)]
txt <- c(expression(paste("Prior: ", f(theta))),
expression(paste("Posterior: f(", theta, "|y,n)")))
sub.txt <- paste("alpha =",alpha," lambda =", lambda," heads =",y," tosses = ",n)
plot(grid1, prior, ylim = c(0, max(posterior) + 1), type="h", pch = ".", col = fill[1],
bty = "l", yaxt = "n", ylab = "", sub = sub.txt,
cex.sub = 0.75, xlab = expression(theta))
points(grid1, posterior, pch=".", type="h", col = new.fill2)
segments(x0 = MAP, y0 = 0, y1 = max(posterior), lty = 2)
points(MAP, max(posterior), pch = 20)
mtext(side = 3, text = txt, col = fill, adj = c(0,1))
text(x = MAP, y = max(posterior), labels = paste("MAP =", round(MAP, 3)), pos = 2)
}
betaPriorPosterior(1,1, sum(coin.tosses == "Heads"), n.tosses)
betaPriorPosterior(alpha = 1, lambda = 1, y = sum(coin.tosses == "Heads"), n = n.tosses)
betaPriorPosterior(alpha = 5, lambda = 5, y = sum(coin.tosses == "Heads"), n = n.tosses)
betaPriorPosterior(alpha = 1, lambda = 1, y = sum(coin.tosses == "Heads"), n = n.tosses)
betaPriorPosterior(alpha = 5, lambda = 5, y = sum(coin.tosses == "Heads"), n = n.tosses)
betaPriorPosterior(alpha = 10, lambda = 10, y = sum(coin.tosses == "Heads"), n = n.tosses)
betaPriorPosterior(alpha = 10^3, lambda = 10^3, y = sum(coin.tosses == "Heads"), n = n.tosses)
betaPriorPosterior(alpha = 5, lambda = 50, y = sum(coin.tosses == "Heads"), n = n.tosses)
betaPriorPosterior(alpha = 45, lambda = 50, y = sum(coin.tosses == "Heads"), n = n.tosses)
betaPriorPosterior(alpha = 45, lambda = 20, y = sum(coin.tosses == "Heads"), n = n.tosses)
betaPriorPosterior(alpha = 20, lambda = 10, y = sum(coin.tosses == "Heads"), n = n.tosses)
betaPriorPosterior(alpha = 1, lambda = 1, y = sum(coin.tosses == "Heads"), n = n.tosses)
betaPriorPosterior(alpha = 5, lambda = 5, y = sum(coin.tosses == "Heads"), n = n.tosses)
betaPriorPosterior(alpha = 10^3, lambda = 10^3, y = sum(coin.tosses == "Heads"), n = n.tosses)
betaPriorPosterior(alpha = 5, lambda = 50, y = sum(coin.tosses == "Heads"), n = n.tosses)
)
betaPriorPosterior(alpha = 20, lambda = 10, y = sum(coin.tosses == "Heads"), n = n.tosses)
betaPriorPosterior(alpha = 20, lambda = 10, y = sum(coin.tosses == "Heads"), n = n.tosses)
betaPriorPosterior(alpha = 5, lambda = 50, y = sum(coin.tosses == "Heads"), n = n.tosses)
betaPriorPosterior(alpha = 5, lambda = 5, y = sum(coin.tosses == "Heads"), n = n.tosses)
betaPriorPosterior(alpha = 10^3, lambda = 10^3, y = sum(coin.tosses == "Heads"), n = n.tosses)
install.packages("rstan")
install.packages("ggvis")
library("ggvis", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
install.packages("testthat")
library("testthat", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
colourise("abc", fg = "red")
print(colourise("abc", fg = "red"))
print(colourise("Red", "red"))
setwd("/Users/jgabry/Desktop/COLUMBIA/Stuff_for_Greg")
#load packages
library(QMSS)
library(plyr)
library(car)
# load data
load("GSS_panel.RData")
load("GSS.RData")
# A simple time series problem --------
vars <- c("cohort", "confinan", "attend", "pray", "conclerg", "homosex", "year",
"sex", "age", "realinc", "marital", "divlaw", "partyid", "polviews",
"babies", "preteen", "teens", "wrkstat", "divorce", "degree")
sub <- GSS[, vars]
# Recodes (using mutate from plyr, but could also use within(sub, ) )
?mutate
sub <- mutate(sub,
kidslt18 = babies + preteen + teens,
married = ifelse(marital == 1, 1, 0),
baplus = ifelse(degree >= 3, 1, 0),
fulltime = ifelse(wrkstat == 1, 1, 0),
womenft = ifelse(sex == 2 & wrkstat == 1, 1, 0),
marriedlt50 = ifelse(married == 1 & age < 50, 1, 0),
degreelt50 = ifelse(baplus == 1 & age <50, 1, 0),
n.confinan = ReverseThis(confinan),
f.partyid = factor(partyid),
f.divlaw = factor(divlaw),
divlaw1 = ifelse(divlaw == 1, 1, 0),
partyid6 = ifelse(partyid == 6, 1, 0),
partyid7 = ifelse(partyid == 7, 1, 0))
vars2 <- c("conclerg", "n.confinan", "fulltime", "attend", "pray", "degreelt50", "cohort",
"homosex", "marriedlt50", "sex", "kidslt18", "age", "realinc", "married", "divlaw",
"polviews", "babies", "preteen", "teens", "wrkstat", "womenft", "degree", "partyid6",
"partyid7", "divlaw1")
by.year <- aggregate(sub[, vars2], list(year = sub$year), mean, na.rm = T)
by.year[30:40, "year"] <- c(1979, 1981, 1992, 1995, seq(1997, 2009, 2))
vars.omit <- c("wrkstat", "divlaw1", "babies", "preteen", "teens")
for(VAR in setdiff(vars2, vars.omit)){
interpolate <- with(by.year, approx(year, get(VAR), method = "linear", xout = by.year[30:40, "year"]))
by.year[30:40, paste(VAR)] <- interpolate$y
}
by.year <- arrange(by.year, year)
by.year <- subset(by.year, year <= 1992)
by.year <- mutate(by.year,
repub = partyid6 + partyid7,
fulltime100 = fulltime*100,
repub100 = repub*100,
degreelt50100 = degreelt50*100)
with(by.year,{
plot(NULL, ylim = c(0,3.5), xlim = range(year), type = "n", xlab = "year", ylab = "", bty = "l")
points(year, fulltime, col = "navyblue", pch = 19)
points(year, n.confinan, col = "maroon", pch = 19)
legend("topright", c("fulltime", "n.confinan"), ncol = 2, pch = 19, col = c("navyblue", "maroon"))
})
plotByYear <- function(data, varname, color = "black", title = NULL, add = FALSE, ...){
plotFun <- ifelse(add == FALSE, "plot", "lines")
dd <- data[,c("year", varname)]
argsList <- list(x = dd, type = "l", bty = "l", lwd = 2, col = color, main = title, ...)
do.call(plotFun, args = argsList)
}
plotByYear(by.year, "fulltime100", "purple4", "Pct working full-time")
plotByYear(by.year, "repub100", "orangered", "Pct strong republican")
plotByYear(by.year, "degreelt50100", "turquoise4", "Pct under 50 with BA+")
par(mfrow = c(3,1))
plot.vars <- c("fulltime100", "repub100", "degreelt50100")
plot.colors <- c("purple4", "orangered", "turquoise4")
for(i in 1:3){
plotByYear(plot.vars[i], plot.colors[i],
data = by.year,
xlab = "", ylab = "",
title = plot.vars[i])
}
par(mfrow = c(1,1))
for(i in 1:3){
ADD <- ifelse(i == 1, F, T)
plotByYear(by.year, plot.vars[i], plot.colors[i],
ylab = "Percent", ylim = c(0,100),
add = ADD)
}
legend("top", legend = c("Work Full-Time", "Strong Republican", "<50 with BA"),
col = plot.colors, lwd = 2, bty = "n", seg.len = 1)
cor.vars <- c("n.confinan", "fulltime100", "repub100", "degreelt50100", "year")
cor(by.year[, cor.vars], use = "complete")
lm.confinan <- lm(n.confinan ~ fulltime100, data = by.year)
summary(lm.confinan)
# test for heteroskedasticity
bptest(lm.confinan)
e <- lm.confinan$resid
acf(e)
acf(e, xlim = c(1,8), # don't plot for lag = 0
col = "red", lwd = 2)
acf(e, xlim = c(1,8), col = "red", lwd = 2) # can also customize acf output
plot(e)
bgtest
durbinWatsonTest(lm.confinan, max.lag=3) # Durbin-Watson with more lags
lm.confinan2 <- update(lm.confinan, ~ . + year)
summary(lm.confinan2)
e2 <- lm.confinan2$resid
acf(e2, xlim = c(1,8), col = "red", lwd = 2)
plot(e2)
dwtest(lm.confinan2)
bgtest(lm.confinan2)
durbinWatsonTest(lm.confinan2, max.lag=3)
vif(lm.confinan3) # variance inflation factor
lm.confinan3 <- lm(n.confinan ~ fulltime100 + repub100 + degreelt50100 + year, data = by.year)
summary(lm.confinan3)
vif(lm.confinan3) # variance inflation factor
durbinWatsonTest(lm.confinan3, max.lag=2)
coeftest(lm.confinan3, vcov = NeweyWest)
NWvcov <- NeweyWest(lm.confinan3, lag = 1)
coeftest(lm.confinan3, vcov = NWvcov)
coeftest(lm.confinan3, vcov = NeweyWest)
coeftest(lm.confinan3, vcov. = NeweyWest)
coeftest(lm.confinan3, vcov = NeweyWest)
NWvcov <- NeweyWest(lm.confinan3)
coeftest(lm.confinan3, vcov = NWvcov)
coeftest(lm.confinan3, vcov = NeweyWest)
by.yearFD <- summarise(by.year,
n.confinan = firstD(n.confinan), # using firstD functon from QMSS package
fulltime100 = firstD(fulltime100),
repub100 = firstD(repub100),
degreelt50100 = firstD(degreelt50100),
year = year)
lm.confinan4 <- lm(n.confinan ~ fulltime100 + repub100 + degreelt50100 + year, data = by.yearFD)
summary(lm.confinan4)
e4 <- lm.confinan4$resid
plot(e4)
acf(e4, xlim = c(1,6), col = "red", lwd = 2)
library("orcutt")
cochrane.orcutt(lm.confinan3)
coeftest(lm.confinan3)
coeftest(lm.confinan3, vcov = NeweyWest)
library(devtools)
library(devtools)
library(roxygen2)
setwd("/Users/jgabry/Desktop/COLUMBIA/Stuff_for_Greg/QMSS/Package")
setwd("./QMSS")
document()
setwd("..")
install("QMSS")
library(QMSS)
?firstD
library("roxygen2", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
library("devtools", lib.loc="/Library/Frameworks/R.framework/Versions/3.1/Resources/library")
unload("QMSS")
install.packages("devtools", dependencies = TRUE)
install.packages("devtools", dependencies = TRUE)
library(devtools)
install_github("jgabry/QMSS/Package")
install_github("jgabry/QMSS/Package/QMSS")
?QMSS
library(QMSS)
?QMSS
??QMSS
help.search(package = "QMSS")
?QMSS
??QMSS
?QMSS
help(package="QMSS")
